package raida

import (
	"context"
	"encoding/hex"
	"strconv"

	"github.com/CloudCoinConsortium/superraidaclientbackend/internal/cloudcoin"
	"github.com/CloudCoinConsortium/superraidaclientbackend/internal/config"
	"github.com/CloudCoinConsortium/superraidaclientbackend/internal/logger"
	"github.com/CloudCoinConsortium/superraidaclientbackend/internal/perror"
	"github.com/CloudCoinConsortium/superraidaclientbackend/internal/utils"
)


type Fix struct {
	Servant
}

type FixOutput struct {
  // Array of batches of 25 tickets
  Tickets [][]string `json:"tickets"`
  Details [][]string `json:"details,omitempty"`
}

type FixResult struct {
  CoinsFixed int
  CoinsNotFixed int
}

func NewFix(progressChannel chan interface{}) *Fix {
	return &Fix{
		*NewServant(progressChannel),
	}
}

// No real need for that so far. Batches are generated by the client or the Fix Worker

func (v *Fix) ProcessFix(ctx context.Context, ridx int, ccs []cloudcoin.CloudCoin, tickets[] string, pg string) (*FixResult, error) {
  logger.L(ctx).Debugf("Fixing %d notes on raida %d", len(ccs), ridx)

  isSky := false
  for _, cc := range(ccs) {
    isSky = cc.IsIDCoin()
    break
  }

	params := make([][]byte, v.Raida.TotalServers())
  cce, err := v.GetEncryptionCoin(ctx)
  if err != nil {
    logger.L(ctx).Warnf("Failed to get ID coin to encrypt body. Do you have at least one ID coin?")
  }

  if isSky {
    params[ridx] = v.GetHeaderSky(COMMAND_FIX, ridx, cce)
  } else {
    params[ridx] = v.GetHeader(COMMAND_FIX, ridx, cce)
  }

  
  encb := make([]byte, 0)
  encb = append(encb, v.GetChallenge()...)

  for _, cc := range(ccs) {
    sn := cc.Sn
    cbyte := utils.ExplodeSn(sn)
    encb = append(encb, cbyte...)
  }

  pgb, err := hex.DecodeString(pg)
  if err != nil {
    logger.L(ctx).Errorf("Failed to decode PG: %s", err.Error())
    return nil, perror.New(perror.ERROR_DECODE_HEX, "Failed to decode PG: " + err.Error())
  }

  encb = append(encb, pgb...)

  for _, ticket := range(tickets) {
    if ticket == "" {
      ticket = "00000000"
    }

    data, _ := hex.DecodeString(ticket)
    encb = append(encb, data...)
  }

  encb = append(encb, v.GetSignature()...)
  encb, err = v.EncryptIfRequired(ctx, cce, ridx, encb)
  if err != nil {
    logger.L(ctx).Errorf("Failed to encrypt body for R%d: %s", ridx, err.Error())
    return nil, err
  }

  params[ridx] = append(params[ridx], encb...)

  v.UpdateHeaderUdpPackets(params)
	results := v.Raida.SendRequestToSpecificRS(ctx, params, 0, []int{ridx})
  pownArray, _ := v.ProcessGenericResponsesIgnoreUntried(ctx, ccs, results, v.CommonMixedSuccessFunction, cce)

  status := pownArray[ridx]
  if status != config.RAIDA_STATUS_PASS && status != config.RAIDA_STATUS_FAIL {
    logger.L(ctx).Errorf("Failed to fix coins on raida %d. Status %d", ridx, status)
    for idx, _ := range(ccs) {
      ccs[idx].Grade()
    }
    return nil, perror.New(perror.ERROR_FAILED_TO_FIX, "Invalid status from RAIDA")
  }

  fr := &FixResult{}
  for idx, _ := range(ccs) {
    ccs[idx].Grade()

    logger.L(ctx).Debugf("Fix done for cc %d: %s. Result: %s", ccs[idx].Sn, ccs[idx].GetPownString(), ccs[idx].GetGradeStatusString())

    if ccs[idx].Statuses[ridx] == config.RAIDA_STATUS_PASS {
      fr.CoinsFixed += ccs[idx].GetDenomination()
      h := strconv.Itoa(ridx) + strconv.Itoa(int(ccs[idx].Sn)) + pg
      an := cloudcoin.GetANFromPG(ridx, ccs[idx].Sn, pg)

      logger.L(ctx).Debugf("Setting an%d for sn%d to %s h=%s", ridx, ccs[idx].Sn, an, h)
      ccs[idx].SetAn(ridx, an)
    } else {
      fr.CoinsNotFixed += ccs[idx].GetDenomination()
    }
  }

  return fr, nil
}

// We use ANs instead of PG
func (v *Fix) ProcessSkyFix(ctx context.Context, ridx int, cc *cloudcoin.CloudCoin, tickets[] string) (bool, error) {
  logger.L(ctx).Debugf("Fixing  sn %d on raida %d", cc.Sn, ridx)

	params := make([][]byte, v.Raida.TotalServers())
  cce, err := v.GetEncryptionCoin(ctx)
  if err != nil {
    logger.L(ctx).Warnf("Failed to get ID coin to encrypt body. Do you have at least one ID coin?")
  }

  params[ridx] = v.GetHeaderSky(COMMAND_FIX_V2, ridx, cce)

 // v.SetVersion(params[ridx], 2)

  
  encb := make([]byte, 0)
  encb = append(encb, v.GetChallenge()...)

  sn := cc.Sn
  cbyte := utils.ExplodeSn(sn)
  encb = append(encb, cbyte...)

  
  an, err := hex.DecodeString(cc.Ans[ridx])
  if err != nil {
    logger.L(ctx).Errorf("Failed to decode PG: %s", err.Error())
    return false, perror.New(perror.ERROR_DECODE_HEX, "Failed to decode PG: " + err.Error())
  }

  encb = append(encb, an...)

  for _, ticket := range(tickets) {
    if ticket == "" {
      ticket = "00000000"
    }

    data, _ := hex.DecodeString(ticket)
    encb = append(encb, data...)
  }

  encb = append(encb, v.GetSignature()...)
  encb, err = v.EncryptIfRequired(ctx, cce, ridx, encb)
  if err != nil {
    logger.L(ctx).Errorf("Failed to encrypt body for R%d: %s", ridx, err.Error())
    return false, err
  }

  params[ridx] = append(params[ridx], encb...)

  v.UpdateHeaderUdpPackets(params)


	results := v.Raida.SendRequestToSpecificRS(ctx, params, 0, []int{ridx})
  pownArray, _ := v.ProcessGenericResponses(ctx, nil, results, v.CommonMixedSuccessFunction)

  status := pownArray[ridx]
  if status != config.RAIDA_STATUS_PASS && status != config.RAIDA_STATUS_FAIL {
    logger.L(ctx).Errorf("Failed to fix coins on raida %d. Status %d", ridx, status)
    return false, perror.New(perror.ERROR_FAILED_TO_FIX, "Invalid status from RAIDA")
  }

  cc.Statuses[ridx] = status
  cc.Grade()

  logger.L(ctx).Debugf("Fix done for cc %d: %s. Result: %s", cc.Sn, cc.GetPownString(), cc.GetGradeStatusString())

  if cc.Statuses[ridx] == config.RAIDA_STATUS_PASS {
    logger.L(ctx).Debugf("Fixed successfully on r%d",  ridx)
    return true, nil
  }

  logger.L(ctx).Debugf("Fixed successfully on r%d",  ridx)

  return false, perror.New(perror.ERROR_FAILED_TO_FIX, "Failed to fix")
}



